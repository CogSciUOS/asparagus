from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

import os
import sys

import traceback

from label_dialog_ui import *
import numpy as np

import numpy as np
import pandas as pd
import imageio

import re
from feature_extraction.feature_extraction import *
from feature_extraction.color_plot import color_plot

from pandas_model import PandasModel


class LabelingDialog(QWidget):
    def __init__(self, widget_handled, ui):
        """ Initializes the labeling Dialog
        Args:
            widget_handeled: Events for this widget are handeled by LabelingDialog to access arrow keys
            ui: User interface generated by pyuic5 (view)
        """
        self.thread = LabelingDialog.Features(self)
        self.extract_features = False
        self.ui = ui
        self.make_conncections()
        self.widget_handled = widget_handled #Widget for event Handling. All events are checked and if not arrow keys passed on. See eventFilter below
        QWidget.__init__(self, widget_handled)

        self.outpath = None#Thr path of the output csv
        self.labels = None#After loading a dictionary that contains: key=*index of asparagus* to value=*list of properties*

        self.idx_image = 0#Relates to the index of the current asparagus piece i.e. the index of the corresponding three files
        self.images = {}
        self.ui.color.set_gray_background()


        headers_main_variables = ["is_bruch","is_hollow","has_blume","has_rost_head","has_rost_body","is_bended","is_violet","very_thick","thick","medium_thick","thin","very_thin","unclassified"]
        headers_set_via_feature_extraction = ["auto_violet","auto_blooming","auto_length","auto_rust_head","auto_rust_body","auto_width","auto_bended"]
        headers_additional_extracted_features = ["filenames"]

        self.outfile_headers = []
        self.outfile_headers.extend(headers_main_variables)
        self.outfile_headers.extend(headers_set_via_feature_extraction)
        self.outfile_headers.extend(headers_additional_extracted_features)

        self.questions = headers_main_variables[:-1]#Questions must be the first rows in out


        self.feature_to_questions = { "width":["very_thick","thick","medium_thick","thin","very_thin"],
                                 "blooming":["has_blume"],
                                 "length":["is_bruch"],
                                 "rust":["has_rost_head","has_rost_body"],
                                 "violet":["is_violet"],
                                 "bended":["is_bended"]
                                }
        self.automatic = []

        self.idx_question = 0
        self.ui.question.setText(self.questions[self.idx_question])
        self.update_info()

    def not_classifiable(self):
        """ Sets a value in the outputfile that indicates the asparagus piece was not classifiable"""
        try:
            self.set_value_for_label(1, "unclassified")
            self.next_image()
        except e as Exception:
            print(e)

    def use_feature_extraction_for(self, feature):
        """ Specifies for which features the user wants to rely on automaticlly extracted features.
            Questions for the feature being extracted automatically are not posed to the user for manual labeling.
            Args:
                feature: The feature (see: self.feature_to_questions.keys()) that should not be estimated by the user manually.
        """
        remove = self.feature_to_questions[feature]
        for x in remove:
            self.questions.remove(x)

    def use_question_for(self, feature):
        """ Specifies features the user wants questions to be asked for. Adds the respective questions to add to the list of questions asked for labeling (self.questions) """
        self.questions.extend(self.feature_to_questions[feature])

    def make_conncections(self):
        """ Establish connections between UI elements and functionalities"""
        self.ui.asparagus_number.valueChanged.connect(lambda x: self.set_index(int(x)))
        self.ui.previous_question.clicked.connect(self.previous_question)
        self.ui.next_question.clicked.connect(self.next_question)
        self.ui.yes.clicked.connect(self.answer_yes)
        self.ui.no.clicked.connect(self.answer_no)
        self.ui.notClassifiable.clicked.connect(self.not_classifiable)

        self.ui.usePredictionLength.stateChanged.connect(lambda x: self.use_feature_extraction_for("length") if x else self.use_question_for("length"))
        self.ui.usePredictionBlooming.stateChanged.connect(lambda x: self.use_feature_extraction_for("blooming") if x else self.use_question_for("blooming"))
        self.ui.usePredictionRust.stateChanged.connect(lambda x: self.use_feature_extraction_for("rust") if x else self.use_question_for("rust"))
        self.ui.usePredictionWidth.stateChanged.connect(lambda x: self.use_feature_extraction_for("width") if x else self.use_question_for("width"))
        self.ui.usePredictionBended.stateChanged.connect(lambda x: self.use_feature_extraction_for("bended") if x else self.use_question_for("bended"))
        self.ui.usePredictionViolet.stateChanged.connect(lambda x: self.use_feature_extraction_for("violet") if x else self.use_question_for("violet"))

        self.ui.extractFeatures.toggled.connect(self.toggle_feature_extraction)

        self.thread.color_plot.connect(self.ui.color.update)

        # The following connections are made to link the results of the feature extraction thread to ui elements or the methods of self thats save them to the output csv file.
        self.thread.predictionWidth.connect(self.ui.predictionWidth.setText)
        self.thread.predictionBended.connect(self.ui.predictionBended.setText)
        self.thread.predictionLength.connect(self.ui.predictionLength.setText)
        self.thread.predictionViolet.connect(self.ui.predictionViolet.setText)
        self.thread.predictionRust.connect(self.ui.predictionRust.setText)
        self.thread.predictionBlooming.connect(self.ui.predictionBlooming.setText)

        self.thread.predictionWidth_2.connect(self.ui.predictionWidth_2.setText)
        self.thread.predictionBended_2.connect(self.ui.predictionBended_2.setText)
        self.thread.predictionLength_2.connect(self.ui.predictionLength_2.setText)
        self.thread.predictionViolet_2.connect(self.ui.predictionViolet_2.setText)
        self.thread.predictionRust_2.connect(self.ui.predictionRust_2.setText)
        self.thread.predictionBlooming_2.connect(self.ui.predictionBlooming_2.setText)

        self.thread.predictionWidth_3.connect(self.ui.predictionWidth_3.setText)
        self.thread.predictionBended_3.connect(self.ui.predictionBended_3.setText)
        self.thread.predictionLength_3.connect(self.ui.predictionLength_3.setText)
        self.thread.predictionViolet_3.connect(self.ui.predictionViolet_3.setText)
        self.thread.predictionRust_3.connect(self.ui.predictionRust_3.setText)
        self.thread.predictionBlooming_3.connect(self.ui.predictionBlooming_3.setText)

        self.thread.overallPredictionWidth.connect(self.ui.overallPredictionWidth.setText)
        self.thread.overallPredictionWidth.connect(lambda x: self.set_value_for_label(x, "auto_width",self.idx_image))
        self.thread.overallPredictionBended.connect(self.ui.overallPredictionBended.setText)
        self.thread.overallPredictionBended.connect(lambda x: self.set_value_for_label(x, "auto_bended",self.idx_image))
        self.thread.overallPredictionLength.connect(self.ui.overallPredictionLength.setText)
        self.thread.overallPredictionLength.connect(lambda x: self.set_value_for_label(x, "auto_length",self.idx_image))
        self.thread.overallPredictionViolet.connect(self.ui.overallPredictionViolet.setText)
        self.thread.overallPredictionViolet.connect(lambda x: self.set_value_for_label(x, "auto_violet",self.idx_image))
        self.thread.overallPredictedValueRust.connect(self.ui.overallPredictedValueRust.setText)
        self.thread.overallPredictionBlooming.connect(self.ui.overallPredictionBlooming.setText)

    def toggle_feature_extraction(self):
        """ Toggles the automatic extraction of features """
        self.extract_features = not self.extract_features
        self.set_index(self.idx_image)

    def set_output_file(self, path):
        """ Sets output file
            Args:
                path
        """
        self.outpath = path
        self.load_outfile()

    def load_outfile(self):
        """ Loads outputfile if it exists and saves contents to self.dict.
            Sets self.labels to an empty dict otherwise."""
        try:
            recovered = pd.read_csv(self.outpath, index_col=0, sep =";").to_dict(orient="index")
            for key, value in recovered.items():
                recovered[key] = list(recovered[key].values())
            self.labels = recovered
        except FileNotFoundError:
            self.labels = {}
        except Exception as e:
            print(e)

    def answer_yes(self):
        """ Writes answer (yes) to current question to file """
        self.log_answer(1)
        self.ui.yes.setFocus()
        self.next_question()

    def answer_no(self):
        """ Writes answer (no) to current question to file """
        self.log_answer(0)
        self.ui.no.setFocus()
        self.next_question()

    def set_value_for_label(self, value, label, idx = None):
        """ Sets value for a given label. Exception passed on if self.labels is not set yet.
        Args:
            value: The value the feature should be set to
            label: The label tha value of which shall be updated
            idx: The index of the aspargus piece. If no value is specified the index of the asparagus piece currently being displayed is used.
        """
        if not type(self.labels) == type({}):
            QMessageBox.about(self, "Attention", "Load output file first.")
            return

        if idx == None:
            idx = self.idx_image

        try:#Assure we have a line of data for the current index
            self.labels[idx]
        except KeyError:
            self.labels[idx] = [None for x in range(len(self.outfile_headers))]

        try:
            self.labels[idx][self.outfile_headers.index(label)] = value
        except Exception as e:
            print("Couldn't set label")
            print(e)

    def log_answer(self, answer):
        """ Logs answer for current question and asparagus piece
        Args:
            answer: The answer to be logged for the current question. It will be writtent to the outputfile once you jump to the next piece.

        """
        self.set_value_for_label(answer,self.questions[self.idx_question])

    def write_answers_to_file(self):
        """ Writes answer to questions for current idx to file """
        self.set_value_for_label(str(self.images[self.idx_image]),"filenames")
        try:
            df = pd.DataFrame.from_dict(self.labels, orient = "index", columns=self.outfile_headers)
            df.to_csv(self.outpath,sep =";")
        except:
            QMessageBox.about(self, "Attention", "Writing file failed.")

    def previous_question(self):
        """ Changes index to previous file and draws respective asparagus"""
        if(self.idx_question==0):
            self.previous_image()
            self.idx_question = len(self.questions)-1
        else:
            self.idx_question -= 1
        self.ui.question.setText(self.questions[self.idx_question])

    def next_question(self):
        """ Changes index to next file and draws respective asparagus"""
        if(self.idx_question==len(self.questions)-1):
            if self.thread.isRunning():
                QMessageBox.about(self, "Attention", "Feature extraction still running")
                return
            self.next_image()
            self.idx_question = 0
        else:
            self.idx_question += 1
        self.ui.question.setText(self.questions[self.idx_question])


    def set_images(self, idx_to_list_of_paths):
        """ Sets nested list of image filepaths depicting the asparagus piece from all three directions
        Args:
            idx_to_list_of_paths = dict of list of filenames
        """
        self.images = idx_to_list_of_paths


    def next_image(self):
        """ Increases self.idx_image if this index exists. Important: This method is the only one that writes the answet to the file."""
        self.write_answers_to_file()
        self.set_index(self.idx_image+1)
        if not self.idx_image in self.images:#In case of failure a message is printed elsewhere
            self.set_index(self.idx_image-1)

    def previous_image(self):
        """ Decreases self.idx_image if this index exists"""
        self.set_index(self.idx_image-1)
        if not self.idx_image in self.images:#In case of failure a message is printed elsewhere
            self.set_index(self.idx_image+1)

    class Features(QThread):
        color_plot = pyqtSignal(np.ndarray)
        predictionWidth = pyqtSignal(str)
        predictionBended = pyqtSignal(str)
        predictionLength = pyqtSignal(str)
        predictionViolet = pyqtSignal(str)
        predictionRust = pyqtSignal(str)
        predictionBlooming = pyqtSignal(str)

        predictionWidth_2 = pyqtSignal(str)
        predictionBended_2 = pyqtSignal(str)
        predictionLength_2 = pyqtSignal(str)
        predictionViolet_2 = pyqtSignal(str)
        predictionRust_2 = pyqtSignal(str)
        predictionBlooming_2 = pyqtSignal(str)

        predictionWidth_3 = pyqtSignal(str)
        predictionBended_3 = pyqtSignal(str)
        predictionLength_3 = pyqtSignal(str)
        predictionViolet_3 = pyqtSignal(str)
        predictionRust_3 = pyqtSignal(str)
        predictionBlooming_3 = pyqtSignal(str)

        overallPredictionWidth = pyqtSignal(str)
        overallPredictionBended = pyqtSignal(str)
        overallPredictionLength = pyqtSignal(str)

        overallPredictionViolet = pyqtSignal(str)
        overallPredictedValueRust = pyqtSignal(str)
        overallPredictionBlooming = pyqtSignal(str)

        def __init__(self, outer):
            """ Initializes the feature extracting thread
            Note that setting features from the thread directly is possible in general as the "factory method" is used to init the thread (self/self.ui is passed to this).
            However setting values to the ui is not inteded by PyQt. To eliminate all potential problems due to parallel updating of values slots/signals are used for communication
            between the thread and self.outer (signals are handled in a queued connection).

            As self.idx_image is used for updating values in self one shall not be able to jump to the next_image (otherwise saving for incorrect image index).
            Hence respective functions are deactivated as long as the thread is running in the methods of LabelingDialog.
            Args:
                outer: Outer instance of class LabelingDialog
            """
            super().__init__()
            self.outer = outer

        def run(self):
            """ Run method of the QThread that is started in parallel when QThread.start() is called. Extracts features emits results as signals. """
            try:
                imgs = [np.array(imageio.imread(fname)) for fname in self.outer.images[self.outer.idx_image]]
                idx_image = self.outer.idx_image#At creation time
            except KeyError:
                #If there are no images for the index for whatever reason. Just dont do anything.
                self.outer.ui.asparagus_number.setEnabled(True)
                return

            try:
                self.color_plot.emit(color_plot(imgs))
            except:
                self.outer.ui.asparagus_number.setEnabled(True)
                return

            try:
                p = [estimate_width(np.rot90(x)) for x in imgs]
                self.predictionWidth.emit(str(int(p[0])))#Numerical widthprint('% 6.2f' % v)
                self.predictionWidth_2.emit(str(int(p[1])))
                self.predictionWidth_3.emit(str(int(p[2])))
                width = np.round(np.mean(np.array(p)))
                self.overallPredictionWidth.emit(str(width))
            except Exception as e:
                print(traceback.format_exc())
                print("Couldn't set auto width")

            try:
                p = [estimate_purple(x, threshold_purple=10) for x in imgs]
                self.predictionViolet.emit(str(p[0]))#Numerical widthprint('% 6.2f' % v)
                self.predictionViolet_2.emit(str(p[1]))
                self.predictionViolet_3.emit(str(p[2]))
                #most_common = Counter(np.array(p)).most_common(1)[0][0]
                purple_estimate = np.round(np.mean(np.array(p)))
                self.overallPredictionViolet.emit(str(purple_estimate))
            except Exception as e:
                print(traceback.format_exc())
                print("Couldn't set auto purple")

            try:
                p = [estimate_bended(x) for x in imgs]
                self.predictionBended.emit(str(int(p[0])))#'{:10.1}'.format(p[0][1]))
                self.predictionBended_2.emit(str(int(p[1])))#'{:10.1}'.format(p[1][1]))
                self.predictionBended_3.emit(str(int(p[2])))#'{:10.1}'.format(p[2][1]))
                #is_bended = np.sum(np.array(p)[:,0])>1#If at least one image shows it's bended
                bended = np.round(np.mean(np.array(p)))
                self.overallPredictionBended.emit(str(bended))
            except Exception as e:
                print(traceback.format_exc())
                print("Couldn't set auto bended")

            try:
                p = [estimate_length(x) for x in imgs]
                self.predictionLength.emit(str(int(np.round(p[0]))))
                self.predictionLength_2.emit(str(int(np.round(p[1]))))
                self.predictionLength_3.emit(str(int(np.round(p[2]))))
                length = np.mean(np.array(p))#TODO
                self.overallPredictionLength.emit(str(int(np.round(length))))
            except Exception as e:
                print(traceback.format_exc())
                print("Couldn't set auto length")

            self.outer.ui.asparagus_number.setEnabled(True)

    def draw_asparagus(self):
        """ Draws image of asparagus pieces from three perspectives"""
        try:
            imgs = []
            max_y = 0
            max_x = 0
            for i, fname in enumerate(self.images[self.idx_image]):
                im = imageio.imread(fname)
                im = np.rot90(im).copy()
                imgs.append(im)

                max_y += im.shape[0]
                if im.shape[1] > max_x:
                    max_x = im.shape[1]

            n_channels = imgs[0].shape[2]
            combined = np.zeros([max_y,max_x,n_channels],dtype=np.uint8)

            y_offset = 0
            for im in imgs:
                combined[y_offset:y_offset+im.shape[0],:im.shape[1],:] = im
                y_offset += im.shape[0]

            self.ui.label.update(np.rot90(combined,3).copy())
        except KeyError:
            QMessageBox.about(self, "Attention", "No images found for current index (" + str(self.idx_image) + ")")
        except Exception as e:
            print(e)
            return

    def update_info(self):
        try:
            msg = ""
            for img_path in self.images[self.idx_image]: # change to idx??
                img_name = re.search(".*/(.*_[a-z]\.png)",img_path).groups()[0]
                msg += " | " + img_name + " | "
            self.ui.asparagus_name.setText(msg)
        except:
            pass

    def set_index(self,idx):
        """ This method sets the current index and starts feature extraction if self.extract_features is True
            (A message is displayed via self.draw_asparagus if no respective image exists).
            Important: This method does not save results of feature extraction of answered questions to the output csv file.
            This allows the user to jump to arbitrary indices without inserting empty lines to the csv.
        Args:
            idx: The index
        """
        if(self.thread.isRunning()):
            QMessageBox.about(self, "Attention", "Feature extraction still running")
            return
        self.idx_image = idx
        self.draw_asparagus()
        self.update_info()

        #The following lines are necessary as otherwise another signal would be emitted that would further increase the index
        self.ui.asparagus_number.blockSignals(True)
        self.ui.asparagus_number.setValue(self.idx_image)
        self.ui.asparagus_number.blockSignals(False)

        self.idx_question = 0
        self.ui.question.setText(self.questions[self.idx_question])

        if self.extract_features:
            self.ui.asparagus_number.setEnabled(False)
            self.thread.start()

    def eventFilter(self, source, event):
        """ Filters key events such that arrow keys may be handled.
            Args:
                source: Source of event
                event: Event to be handled
        """
        if event.type() == QtCore.QEvent.KeyRelease:
            id_right = 16777236
            id_left = 16777234

            if event.key() == id_right:
                self.answer_no()

            elif event.key() == id_left:
                self.answer_yes()

        try:#When closing the app the widget handled might already have been destroyed
            return self.widget_handled.eventFilter(source, event)#Execute the default actions for the event
        except:
            return True#a true value prevents the event from being sent on to other objects
